% !TeX spellcheck = en_US

\chapter{Implementation}\label{chap:imp}
This chapter provides implementation of the framework and his modules and stages, which was described in chapter \ref{chap:conarch}.
For the implementation was chosen a Java language, because of his simplicity and strength. 

\section{Global modules}
This section describes modules, used throughout the whole framework's execution.

\subsection{CSAR handler}
gls{ch} handle common information about CSAR content.
It handles:
\begin{itemize}
	\item Temp extraction folder.
	\item List with files to proceeded.
	\item Meta-file entry.
	\item Architecture of target platform.
\end{itemize}

\subsection{Utils}
This class provides useful methods, used by many other modules.
\begin{itemize}
	\item Create file with content.
	\item Get path deep.
	\item Adapt name for OpenTOSCA.
\end{itemize}

\section{Preprocessing stage}
At the \nameref{subs:archpp} stage a CSAR will be unarchived, common \gls{tosca} definitions generated and internal dependencies found. 

\subsection*{Unarchivating}
For working with archives it was decided to use common Java package $java$.$utils$.$zip$.
The functions of archiving, unarchiving were implemented in one class $zip$ with public methods $zipIt$ and $unZipIt$. $zipIt$ is declared in the listing \ref{lst:unzip}.
\begin{lstlisting}[caption={Method decompress files}\label{lst:unzip},captionpos=t] 

/**
* Unzip it
* 
* @param zipFile
*            input zip file name
* @param outputFolder
*            output folder
*/
static public List<String> unZipIt(String zipFile, String outputFolder);
\end{lstlisting}

\subsection*{Generating TOSCA Definitions}
For generating common gls{tosca} definitions a $javax$.$xml$.$bind$ package was chosen. 
Descriptive descriptions for common definitions were created.
\begin{itemize}
	\item DependsOn and PreDependsOn definitions describe Relationship Types (gls{TOSCA} \nameref{subs:reltype}) for according relations between packages (\nameref{subs:dep}). 
	\item Package Artifact Type defines a deployment Artifact Type for package installation data.
	\item Script Artifact Type defines a implementation Artifact Type for package installation script.
\end{itemize}
example can be found in listing \ref{lst:scripttype}
\if 0
AnsibleArtifactType  определяет имплементатион артифакт типа ансибле содержащий ссылку архив устанавливающий программу 
\\need to add ansible chapter
\fi
\subsection*{Finding internal references}\label{subs:imp_findintref}
\nameref{subs:archtop} mainly uses internal references from \nameref{subs:analyse}.
Therefore, this two modules were combined to one class $Topology$\_$Handler$.	
At the preprocessing stage, he analyses all origin definitions to build internal relations, as was described in section \ref{subs:analyse}.
To read origin definition a package $org$.$w3c$.$dom$ was used.

\section{Search for external references}
This section will describe the finding external dependencies in the original artifacts.
For this purpose serve \nameref{subs:archlm} and \nameref{subs:archpmm}.
Since the framework is initially oriented to easy extensibility, abstract classes for \nameref{subs:archlm} and \nameref{subs:archpmm} will be described.
New language and package manager modules can be added by implementing these methods.

\subsection*{Language Model}
To describe common functionality of different language modules, the abstract class Language was defined in listing \ref{lst:langabst}.
Common components for all language models are: 
\begin{itemize}
	\item Language name
	\item set of package manager modules
	\item Extensions of files
\end{itemize}
Common functions are: 
\begin{itemize}
	\item $getName$ returns this language's name.
	\item $getExtensions$ returns this language's extensions.
	\item $proceed$ checks all original files and transfer results to package manager modules.
	\item $getNodeName$ returns how should TOSCA node installing package with this language be named.
	\item $createTOSCA\_Node$ creates TOSCA definitions for new package. 
	Since created TOSCA definitions depends from original script's language, these languages must provide method for creating the definitions.
\end{itemize}

\subsection*{Package Handler Model}
As with languages, an abstract class is defined at first.
This definition contains only one function $proceed$ (listing \ref{lst:pmabst}) that finds and eliminates external references, as well as passes the package names to package handler.

\subsection*{Bash implementation}
The processing of popular Bash language was implemented.
As a sign of belonging to the Bash language, the file extension (".sh" and ".bash") and the first line ("#!/bin/bash") are used. 
All files that satisfy this conditions are passed to package managers modules, in our case - $apt$-$get$. 
TOSCA node containing a package and bash install script is defined by Node Type, Node Type Implementation, Package Artifact, Script Artifact.
This definitions are created my $createTOSCA\_Node$ method presented in listing \ref{lst:create_bash}.
now consider it in more details.
To avoid creating of the same nodes, we store names of created nodes in $created_packages$ list, and check it before start.
Then language specific node name is generated and TOSCA definitions for this name are created.

\subsubsection*{Apt-get Bash implementation}
The apt-get package manager module processing is fairly simple line-by-line file parser that searches for lines starting with the "$apt$-$get$ $install$" string and passes this command's arguments to package handler's public function $getPackage$ described later. 
The code can be found in the listing \ref{lst:bash_apt_parse}.
\subsection*{Ansible implementation}
To test the extensibility of the framework, the Ansible language was added.
Ansible is oft used for cloud application administration too.
Since ansible files are often packed to archives, it may be necessary to unpack them first and  then analyze the content.
Thus, the files are either immediately transferred to the package handler, or they are unzipped first.
Listing \ref{lst:ansible_proceed} presents this operations.
As a sign of the ansible language, the ".$yml$" extension is used, since this files doesn't contain specific header.\\
Creating a \gls{tosca} node for this language is a long operation. 
The basic moments are:
\begin{itemize}
	\item Analyze original files to determine an ansible configuration (set of options like username or proxy).
	\item It can be necessary to complete a configuration using user input.
	\item Create installation data (executable $yml$ file and folder with package)
	\item Pack installation data
	\item Create TOSCA definitions describing installation data
\end{itemize} 

\subsubsection*{Apt implementation}
Since the package installation using $ansible$ language and $apt$ package manager can be described in many different ways, the processing of is complicated too.
It's worth mentioning that the processing uses a simple state machine and regular expression from $java$.$util$.$regex$.

\section{Package Handler}
Package handler is an interface for interacting with the package manager of the operating system.
Allows to load packages and to determine the type of dependency between them.

\subsection*{Package downloading}
This operation is performed using one recursive function $getPacket$ defined below in listing \ref{lst:getpack}.
\begin{lstlisting}[caption={$getPackage$ definition}\label{lst:getpack},captionpos=t]
/**
* Download package and check its dependency
* 
* @param packet
*            package name
* @param cr
*            CSAR manager
* @param depth
*            dependency level to be checked
* @param listed
*            list with already included packages
* @return list of packages
* @throws JAXBException
* @throws IOException
*/
getPacket(Language language, String packet, List<String> listed, String source, String sourcefile);
\end{lstlisting}
This function downloads packages for full dependency three, calls corresponding Language to create nodes and Topology Handler to update topology.\\
Arguments will be described shortly.
\begin{itemize}
	\item $Language$ is used to coll right $createTOSCA\_Node$ function.
	\item $packet$ defines package-name to download.
	\item $listed$ holds a list with packages already presented in the dependency tree. No need to download them, but dependencies will be created.
	\item $source$ defines parent-element in dependency tree. For root package that will be a source script file, for other packages - depending package.
	\item $sourcefile$ is source script file name. And is used to generate package name and by Languages to get additional information for node creating. 
\end{itemize}
For downloading the command $apt$-$get$ $download$ \emph{package} is used. 
If download fails the command line user-input to solve the problem is used. 

\subsection*{Dependencies}
To determine the dependency type the command $apt$-$cache$ $depends$  \emph{package} is used.
Example output was presented in section \ref{subs:dep}.

\section{Topology handling}
Topology handler serves to update the Service Templates.
For this purpose the \nameref{subs:imp_findintref} stage is executed during preprocessing stage.

\subsection*{Update Service Templates}
To update Service Templates two functions are provided.
\begin{itemize}
	\item $addDependencyToPacket$ generates dependency between two package nodes generated by the framework.
	\item $addDependencyToScript$ generates dependency between original node and package node generated by the framework.
	 
\end{itemize} 
To update existing TOSCA definition the $org$.$w3c$.$dom$ and $org$.$xml$.$sax$ packages are used.

\section{Finishing}
To finish the work changed data should be packed back to \gls{csar}.
Function $zipIt$ from class $zip$, defined in listing \ref{lst:zip} is used.

\begin{lstlisting}[caption={Method to archive files}\label{lst:zip},captionpos=t] 
/**
* Unzip it
* 
* @param zipFile
*            input zip file name
* @param outputFolder
*            output folder
*/
static public List<String> unZipIt(String zipFile, String outputFolder);
\end{lstlisting}