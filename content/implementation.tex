% !TeX spellcheck = en_US

\chapter{Implementation}\label{chap:imp}

\if 0
В этой главе описана имплементация фреймворка. Указано поочерёдное описание каждого из модулей из главы такой то, и связей между ними. Так же будут описаны основые моменты и сложности возникшие при имплементизации.
Для имплементации был выбран язык ява, потому что... хз
\fi
\section{Preprocessing}
\if 0
На этапе препроцессинга необходимо разархивировать архив, сгенерировать общие дефениции тоски и найти внутренние зависимости
\fi
\subsection*{Unarchivating}
\if 0
Для работы с архивами было решено использовать стандартный пакет java.util.zip, его функционала достаточно для работы с архивами. Обе функции архивации и разархивации были вынесены в один ява класс zip представляющий функции архивировать и разархивировать. 
\fi
\subsection*{Generating TOSCA Definitions}
\if 0
ТОска дефинитионс файлы это хмл файлы с заданной структурой, для их генерации  используется пакет javax.xml.bind. Для его работы были описаны дефиниции ТОСКИ в виде ява классов. 
DependsOn зависимость depends смотри главу какую то там
PreDependsOn зависимость предепендс
PackageArtifactType определяет описание деплоймент артифактов содержащих ссылку на пакет для установки 
ScriptArtifactType  определяет имплементатион артифакт содержащий ссылку на скрипт устанавливающий программу из пакета 
AnsibleArtifactType  определяет имплементатион артифакт типа ансибле содержащий ссылку архив устанавливающий программу 
\fi
\subsection*{Finding internal references}
\if 0
Модуль дополнения топологии ТОСКИ использует главным образом внутренние зависимости, в связи с этим эти два модуля были объединены в один ява класс "придумай красивое название". на этапе предобработки он анализирует все исходные данные и строить зависимости по принципу указанному в какой то главе. для чтения хмл файлов был использован пакет org.w3c.dom. может пример кода вставить?

\fi
\section{Search for external references}
\if 0
В этой секции будет описан процесс поиска внешних зависимостей в артифактах архива.
для этой цели служат языки и принадлежащие им обработчики менеджеров пакетов
так как фреймворк изначально ориентирован на лёгкую расширяемость, необходимо описать базовые методы, имплементировав которые можно добавить новый язык или обработчик пакетов.
для этой цели в яве существуют абстрактные классы
\fi
\subsection*{Language Model}
\if 0
для описания модели поведения любово языка был прописан абстрактный класс Language. public abstract language
общими для всех языков были выбраны такие параметры как имя, список обработчиков менеджеров пакетов и расширения файлов данного языка. 

// List of package managers supported by language
protected List<PacketManager> packetManagers;

// Extensions for this language
protected List<String> extensions;

// Language Name
protected String Name;

а общими публичные функции - получение имени, списка расширений и команда на обработку, имплементированая по принципу проверки на расширения и в случае совпадения - передачи файла обработчику менеджером пакетов, так как создаваемые в последствии ноды должы иметь тот же тип что и исходная нода, языки должны предоставить метод создания нод тоски

/**
* get Language name
* 
* @return
*/
public String getName() {
	return Name;
}

/**
* Get supported extensions
* 
* @return list with extensions
*/
public List<String> getExtensions() {
	return extensions;
}

/**
* Proceed file, transfer it to package managers
* 
* @param cr
*            CSAR manager
* @throws FileNotFoundException
* @throws IOException
* @throws JAXBException
*/
public void proceed(Control_references cr) throws FileNotFoundException,
IOException, JAXBException {
	
	/**	Generate Node for TOSCA Topology
	* @param packet
	* @param source
	* @return
	* @throws IOException
	* @throws JAXBException
	*/
	public abstract String createTOSCA_Node(String packet, String source) throws IOException, JAXBException;
	
	это самый простой вариант анализа файлов, в случае необходимости финальная имплементация языка может использовать более сложную конструкцию для проверки
\fi
\subsection*{Package Handler Model}
\if 0
абстрактное описание обработчика менеджера пакетов содержит только одну функцию - обработать. 
На вход он получает имя файла скрипта, который нужно обработать и имя исходного файла. имя исходного файла служит для указания на возможный архив, откуда был взят файл скрипта
	/**
* Proceed given file with different source (like archive)
* 
* @param filename
* @param source
* @throws FileNotFoundException
* @throws IOException
* @throws JAXBException
*/
public abstract void proceed(String filename, String source) throws FileNotFoundException, IOException, JAXBException;
\fi
\subsection*{Bash implementation}
\if 0
Была имплементирована обработка популярного языка БАШ. 
в качестве сигнала для того что файл принадлежит этому языку служит расширение файла (.bash or .sh) и первая строчка файла, какая то там строчка.
все файлы удовлетворяющие этому условию передаются обработчику менеджера пакетов apt-get
Нода тоски отображающая баш скрипт для установки пакета состоит из следующих элементов:
Nodetype, NodeTypeImplementation, PackageArtifact, ScriptArtifact, которые и создаются внутри метода createTOSCA_Node
вставить всю функцию можно как код
\fi
\subsubsection*{Apt-get implementation}
\if 0
Обработчик менеджера пакетов апт-гет представляет собой довольно простой построчный анализатор файла, ищущий строки начинающиеся на апт-гет инсталл и передающий их аргумент менеджеру пактов испльзуя его публичную функцию getPackage(Language, packet, source)
которая будет описана подробнее в разделе таком то. 
надо почистить код и вставить его сюда
\fi
\subsection*{Ansible implementation}
\if 0
Для проверки простоты расширяемости фреймворка был добавлен язык Ансибле, так же часто используемый для админстрирования.
Так как Ансибле кукбукс?? часто упакованы в архивы, может быть сначала необходимо разархивировать архив, а потом уже анализировать  его содержимое. Таким образом файлы или сразу передаются обработчику пакетов, или сначал разархивируются 
тут можно кусок кода 2ух функций
В качестве признака языка ансибле используется расширение .yml, так как особого заголовка эти файлы не содержат.
Создание ноды для ансибле это объёмная задача, код можно найти в листинге где нибудь подальше. тут же будут описаны основные моменты.
проанализировать исходный файл, что определения конфигурации, что такое конфигурация напиши.
Далее необходимо создать все файлы для упаковки в архив. в них входит файл конфигурации, файл описания задачи установки пакета и сам пакет.
Оказалось довольно трудно проанализировать конфигурацию ансибле скриптов, поэтому некоторые параметры необходимо указать вручную
\fi
\subsubsection*{Apt implementation}
Так как команда установки пакетов с помощью менеджера апт в ансибле может быть прописана большим числом разных методов, таких как *******, то и алгоритм обработки не самый компактный и представлен в листинге далекооо внизу
Стоит только упоминуть что обработка использует простой вариант машины состояний и регулярные выражения java.util.regex;
\if 0

\fi
\section{Package Handling}
\if 0
Менеджер пакетов. Представляет из себя интерфейс для взаимодействия с менеджером пекетов операционной сисемы. 
\fi
\subsection*{Package downloading}
\if 0

Предоставляет 1 публичные функции, 
/**
* Download package and check its dependency
* 
* @param packet
*            package name
* @param cr
*            CSAR manager
* @param depth
*            dependency level to be checked
* @param listed
*            list with already included packages
* @return list of packages
* @throws JAXBException
* @throws IOException
*/
getPacket(Language language, String packet,
List<String> listed, String source, String sourcefile)
throws JAXBException, IOException 
для загрузки дерева зависимостей и передачи их менеджеру топологии
описание параметров
в случае если это первый загружаемый пакет в дереве зависимостей, необходимо явно указать используемую архитектуру
короткая вставка
для загрузки используется команда такая то
в случае неудачи используется юзеринпут, предоставляющий такие то опции решения проблемы
после загрузки вызывается функции создания ноды от языка
language.createTOSCA_Node(newName, sourcefile);
и одна функция обновления сервистэмплэйта из менеджера топологии
для создания зависимости от уже созданного нами пакета, или от пакета  из топологии... а это нужно?? посмотри код, может быть всё таки можно убрать?

\fi
\subsection*{Dependencies}
\if 0
для определения типа зависимости используется следующая команда, анализирующая вывод типа 
вставь пример
\fi
\section{Topology Handling}
\if 0
Менеджер топололгии служит для актуализации сервистэмплейтов. для этого на этабе препроцессинга он создаёт что то там
\fi
\subsection*{Update ServiceTemplate}
\if 0
Для обновления сервистэмплейта представлена следующая функция 
одна или 2 функции

описать ли что она делает??

\fi
\section{Finishing}
\if 0
Для завершения необходимо упаковать все изменённые данный обратно в Csar архив
используется функция архивировать из класса зип

\fi