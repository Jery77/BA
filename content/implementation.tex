% !TeX spellcheck = en_US

\chapter{Implementation}\label{chap:imp}

\if 0
В этой главе описана имплементация фреймворка. Указано поочерёдное описание каждого из модулей из главы такой то, и связей между ними. Так же будут описаны основые моменты и сложности возникшие при имплементизации.
Для имплементации был выбран язык ява, потому что... хз
\fi
\section{Preprocessing}
\if 0
На этапе препроцессинга необходимо разархивировать архив, сгенерировать общие дефениции тоски и найти внутренние зависимости
\fi
\subsection*{Unarchivating}
\if 0
Для работы с архивами было решено использовать стандартный пакет java.util.zip, его функционала достаточно для работы с архивами. Обе функции архивации и разархивации были вынесены в один ява класс zip представляющий функции архивировать и разархивировать. 
\fi
\subsection*{Generating TOSCA Definitions}
\if 0
ТОска дефинитионс файлы это хмл файлы с заданной структурой, для их генерации  используется пакет javax.xml.bind. Для его работы были описаны дефиниции ТОСКИ в виде ява классов. 
DependsOn зависимость depends смотри главу какую то там
PreDependsOn зависимость предепендс
PackageArtifactType определяет описание деплоймент артифактов содержащих ссылку на пакет для установки 
ScriptArtifactType  определяет имплементатион артифакт содержащий ссылку на скрипт устанавливающий программу из пакета 
\fi
\subsection*{Finding internal references}
\if 0
Модуль дополнения топологии ТОСКИ использует главным образом внутренние зависимости, в связи с этим эти два модуля были объединены в один ява класс "придумай красивое название". на этапе предобработки он анализирует все исходные данные и строить зависимости по принципу указанному в какой то главе. для чтения хмл файлов был использован пакет org.w3c.dom. может пример кода вставить?

\fi
\section{Search for external references}
\if 0
В этой секции будет описан процесс поиска внешних зависимостей в артифактах архива.
для этой цели служат языки и принадлежащие им обработчики менеджеров пакетов
так как фреймворк изначально ориентирован на лёгкую расширяемость, необходимо описать базовые методы, имплементировав которые можно добавить новый язык или обработчик пакетов.
для этой цели в яве существуют абстрактные классы
\fi
\subsection*{Language Model}
\if 0
для описания модели поведения любово языка был прописан абстрактный класс Language. public abstract language
общими для всех языков были выбраны такие параметры как имя, список обработчиков менеджеров пакетов и расширения файлов данного языка. 

// List of package managers supported by language
protected List<PacketManager> packetManagers;

// Extensions for this language
protected List<String> extensions;

// Language Name
protected String Name;

а общими публичные функции - получение имени, списка расширений и команда на обработку, имплементированая по принципу проверки на расширения и в случае совпадения - передачи файла обработчику менеджером пакетов.

/**
* get Language name
* 
* @return
*/
public String getName() {
	return Name;
}

/**
* Get supported extensions
* 
* @return list with extensions
*/
public List<String> getExtensions() {
	return extensions;
}

/**
* Proceed file, transfer it to package managers
* 
* @param cr
*            CSAR manager
* @throws FileNotFoundException
* @throws IOException
* @throws JAXBException
*/
public void proceed(Control_references cr) throws FileNotFoundException,
IOException, JAXBException {
	это самый простой вариант анализа файлов, в случае необходимости финальная имплементация языка может использовать более сложную конструкцию для проверки
\fi
\subsection*{Package Handler Model}
\if 0
абстрактное описание обработчика менеджера пакетов содержит только одну функцию - обработать, представленную в 2ух экземплярах, с или без указания файла-источника скрипта. Такая избыточность была добавленна в связи с наличием заархивированных скриптов. в этом случае артифактом является архив, но редактировать и анализировать необходимо скрипт находящийся внутри.
Метод не использующий указание на источник скрипта подразумевает что анализируемый файл сам по себе является артифактом описанным в топологии ТОСКИ
\fi
\subsection*{Bash implementation}
\if 0

\fi
\subsection*{Apt-get implementation}
\if 0


\fi
\section{Package Handling}
\if 0

\fi
\subsection*{Package downloading}
\if 0

\fi
\subsection*{Dependencies}
\if 0

\fi
\section{Topology Handling}
\if 0

\fi
\subsection*{Generate TOSCA Definitions}
\if 0

\fi
\subsection*{Update ServiceTemplate}
\if 0


\fi
\section{Finishing}
\if 0


\fi