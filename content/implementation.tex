% !TeX spellcheck = en_US

\chapter{Implementation}\label{chap:imp}
This chapter provides implementation of the framework and his modules and stages, which was described in chapter \ref{chap:conarch}.
For the implementation was chosen a Java language, because of his simplicity and strength. 

\section{Preprocessing stage}
At the \nameref{subs:archpp} stage a CSAR will be unarchived, common gls{tosca} definitions generated and internal dependencies found. 

\subsection*{Unarchivating}
For working with archives it was decided to use common Java package $java$.$utils$.$zip$.
The functions of archiving, unarchiving were implemented in one class $zip$ with public methods zipIt and unZipIt declared in listing \ref{lst:zip}.
\begin{lstlisting}[caption={Methods to handle archive files}\label{lst:zip},captionpos=t] 

/**
* Unzip it
* 
* @param zipFile
*            input zip file name
* @param outputFolder
*            output folder
*/
static public List<String> unZipIt(String zipFile, String outputFolder);

/**
* Zip all files in folder
* 
* @param zipFile
*            output ZIP file name
* @param folder
*            folder with files for archivating
*/
static public void zipIt(String zipFile, String folder);
\end{lstlisting}

\subsection*{Generating TOSCA Definitions}
For generating common gls{tosca} definitions a $javax$.$xml$.$bind$ package was chosen. 
Descriptive descriptions for common definitions were created.
\begin{itemize}
	\item DependsOn and PreDependsOn definitions describe Relationship Types (gls{TOSCA} \nameref{subs:reltype}) for according relations between packages (\nameref{subs:dep}). 
	\item Package Artifact Type defines a deployment Artifact Type for package installation data.
	\item Script Artifact Type defines a implementation Artifact Type for package installation script.
\end{itemize}
example can be found in listing \ref{lst:scripttype}
\if 0
AnsibleArtifactType  определяет имплементатион артифакт типа ансибле содержащий ссылку архив устанавливающий программу 
\\need to add ansible chapter
\fi
\subsection*{Finding internal references}
\nameref{subs:archtop} mainly uses internal references from \nameref{subs:analyse}.
Therefore, this two modules were combined to one class $Topology$\_$Handler$.	
At the preprocessing stage, he analyses all origin definitions to build internal relations, as was described in section \ref{subs:analyse}.
To read origin definition a package $org$.$w3c$.$dom$ was used.

\section{Search for external references}
This section will describe the finding external dependencies in the original artifacts.
For this purpose serve \nameref{subs:archlm} and \nameref{subs:archpmm}.
Since the framework is initially oriented to easy extensibility, abstract classes for \nameref{subs:archlm} and \nameref{subs:archpmm} will be described.
New language and package manager modules can be added by implementing these methods.

\subsection*{Language Model}
To describe common functionality of different language modules, the abstract class Language was defined in listing \ref{lst:langabst}.
Common components for all language models are: 
\begin{itemize}
	\item Language name
	\item set of package manager modules
	\item Extensions of files
\end{itemize}
Common functions are: 
\begin{itemize}
	\item $getName$ returns this language's name.
	\item $getExtensions$ returns this language's extensions.
	\item $proceed$ checks all original files and transfer results to package manager modules.
	\item $getNodeName$ returns how should TOSCA node installing package with this language be named.
	\item $createTOSCA\_Node$ creates TOSCA definitions for new package. 
	Since created TOSCA definitions depends from original script's language, these languages must provide method for creating the definitions.
\end{itemize}

\subsection*{Package Handler Model}
As with languages, an abstract class is defined at first.
This definition contains only one function $proceed$ (listing \ref{lst:pmabst}) that finds and eliminates external references, as well as passes the package names to package handler.

\subsection*{Bash implementation}
The processing of popular Bash language was implemented.
As a sign of belonging to the Bash language, the file extension (".sh" and ".bash") and the first line ("#!/bin/bash") are used. 
All files that satisfy this conditions are passed to package managers modules, in our case - $apt$-$get$. 
TOSCA node containing a package and bash install script is defined by Node Type, Node Type Implementation, Package Artifact, Script Artifact.
This definitions are created my $createTOSCA\_Node$ method presented in listing \ref{lst:create_bash}.
now consider it in more details.
To avoid creating of the same nodes, we store names of created nodes in $created_packages$ list, and check it before start.
Then language specific node name is generated and TOSCA definitions for this name are created.

\subsubsection*{Apt-get implementation}
\if 0
Обработчик менеджера пакетов апт-гет представляет собой довольно простой построчный анализатор файла, ищущий строки начинающиеся на апт-гет инсталл и передающий их аргумент менеджеру пактов испльзуя его публичную функцию getPackage(Language, packet, source)
которая будет описана подробнее в разделе таком то. 
надо почистить код и вставить его сюда
\fi
\subsection*{Ansible implementation}
\if 0
Для проверки простоты расширяемости фреймворка был добавлен язык Ансибле, так же часто используемый для админстрирования.
Так как Ансибле кукбукс?? часто упакованы в архивы, может быть сначала необходимо разархивировать архив, а потом уже анализировать  его содержимое. Таким образом файлы или сразу передаются обработчику пакетов, или сначал разархивируются 
тут можно кусок кода 2ух функций
В качестве признака языка ансибле используется расширение .yml, так как особого заголовка эти файлы не содержат.
Создание ноды для ансибле это объёмная задача, код можно найти в листинге где нибудь подальше. тут же будут описаны основные моменты.
проанализировать исходный файл, что определения конфигурации, что такое конфигурация напиши.
Далее необходимо создать все файлы для упаковки в архив. в них входит файл конфигурации, файл описания задачи установки пакета и сам пакет.
Оказалось довольно трудно проанализировать конфигурацию ансибле скриптов, поэтому некоторые параметры необходимо указать вручную
\fi
\subsubsection*{Apt implementation}
\if 0
Так как команда установки пакетов с помощью менеджера апт в ансибле может быть прописана большим числом разных методов, таких как *******, то и алгоритм обработки не самый компактный и представлен в листинге далекооо внизу
Стоит только упоминуть что обработка использует простой вариант машины состояний и регулярные выражения java.util.regex;

\fi
\section{Package Handling}
\if 0
Менеджер пакетов. Представляет из себя интерфейс для взаимодействия с менеджером пекетов операционной сисемы. 
\fi
\subsection*{Package downloading}
\if 0

Предоставляет 1 публичные функции, 
/**
* Download package and check its dependency
* 
* @param packet
*            package name
* @param cr
*            CSAR manager
* @param depth
*            dependency level to be checked
* @param listed
*            list with already included packages
* @return list of packages
* @throws JAXBException
* @throws IOException
*/
getPacket(Language language, String packet,
List<String> listed, String source, String sourcefile)
throws JAXBException, IOException 
для загрузки дерева зависимостей и передачи их менеджеру топологии
описание параметров
в случае если это первый загружаемый пакет в дереве зависимостей, необходимо явно указать используемую архитектуру
короткая вставка
для загрузки используется команда такая то
в случае неудачи используется юзеринпут, предоставляющий такие то опции решения проблемы
после загрузки вызывается функции создания ноды от языка
language.createTOSCA_Node(newName, sourcefile);
и одна функция обновления сервистэмплэйта из менеджера топологии
для создания зависимости от уже созданного нами пакета, или от пакета  из топологии... а это нужно?? посмотри код, может быть всё таки можно убрать?

\fi
\subsection*{Dependencies}
\if 0
для определения типа зависимости используется следующая команда, анализирующая вывод типа 
вставь пример
\fi
\section{Topology Handling}
\if 0
Менеджер топололгии служит для актуализации сервистэмплейтов. для этого на этабе препроцессинга он создаёт что то там
\fi
\subsection*{Update ServiceTemplate}
\if 0
Для обновления сервистэмплейта представлена следующая функция 
одна или 2 функции

описать ли что она делает??

\fi
\section{Finishing}
\if 0
Для завершения необходимо упаковать все изменённые данный обратно в Csar архив
используется функция архивировать из класса зип

\fi