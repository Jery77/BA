% !TeX spellcheck = en_US

\chapter{Implementation}\label{chap:imp}
This chapter provides implementation of the framework and his modules and stages, which was described in chapter \ref{chap:conarch}.
For the implementation was chosen a Java language, because of his simplicity and strength. 

\section{Global modules}
This section describes modules, used throughout the whole framework's execution.

\subsection{CSAR handler}
gls{ch} handle common information about CSAR content.
It handles:
\begin{itemize}
	\item Temp extraction folder.
	\item List with files to proceeded.
	\item Meta-file entry.
	\item Architecture of target platform.
\end{itemize}

\subsection{Utils}
This class provides useful methods, used by many other modules.
\begin{itemize}
	\item Create file with content.
	\item Get path deep.
	\item Adapt name for OpenTOSCA.
\end{itemize}

\section{Preprocessing stage}
At the \nameref{subs:archpp} stage a CSAR will be unarchived, common gls{tosca} definitions generated and internal dependencies found. 

\subsection*{Unarchivating}
For working with archives it was decided to use common Java package $java$.$utils$.$zip$.
The functions of archiving, unarchiving were implemented in one class $zip$ with public methods zipIt and unZipIt declared in listing \ref{lst:zip}.
\begin{lstlisting}[caption={Methods to handle archive files}\label{lst:zip},captionpos=t] 

/**
* Unzip it
* 
* @param zipFile
*            input zip file name
* @param outputFolder
*            output folder
*/
static public List<String> unZipIt(String zipFile, String outputFolder);

/**
* Zip all files in folder
* 
* @param zipFile
*            output ZIP file name
* @param folder
*            folder with files for archivating
*/
static public void zipIt(String zipFile, String folder);
\end{lstlisting}

\subsection*{Generating TOSCA Definitions}
For generating common gls{tosca} definitions a $javax$.$xml$.$bind$ package was chosen. 
Descriptive descriptions for common definitions were created.
\begin{itemize}
	\item DependsOn and PreDependsOn definitions describe Relationship Types (gls{TOSCA} \nameref{subs:reltype}) for according relations between packages (\nameref{subs:dep}). 
	\item Package Artifact Type defines a deployment Artifact Type for package installation data.
	\item Script Artifact Type defines a implementation Artifact Type for package installation script.
\end{itemize}
example can be found in listing \ref{lst:scripttype}
\if 0
AnsibleArtifactType  определяет имплементатион артифакт типа ансибле содержащий ссылку архив устанавливающий программу 
\\need to add ansible chapter
\fi
\subsection*{Finding internal references}
\nameref{subs:archtop} mainly uses internal references from \nameref{subs:analyse}.
Therefore, this two modules were combined to one class $Topology$\_$Handler$.	
At the preprocessing stage, he analyses all origin definitions to build internal relations, as was described in section \ref{subs:analyse}.
To read origin definition a package $org$.$w3c$.$dom$ was used.

\section{Search for external references}
This section will describe the finding external dependencies in the original artifacts.
For this purpose serve \nameref{subs:archlm} and \nameref{subs:archpmm}.
Since the framework is initially oriented to easy extensibility, abstract classes for \nameref{subs:archlm} and \nameref{subs:archpmm} will be described.
New language and package manager modules can be added by implementing these methods.

\subsection*{Language Model}
To describe common functionality of different language modules, the abstract class Language was defined in listing \ref{lst:langabst}.
Common components for all language models are: 
\begin{itemize}
	\item Language name
	\item set of package manager modules
	\item Extensions of files
\end{itemize}
Common functions are: 
\begin{itemize}
	\item $getName$ returns this language's name.
	\item $getExtensions$ returns this language's extensions.
	\item $proceed$ checks all original files and transfer results to package manager modules.
	\item $getNodeName$ returns how should TOSCA node installing package with this language be named.
	\item $createTOSCA\_Node$ creates TOSCA definitions for new package. 
	Since created TOSCA definitions depends from original script's language, these languages must provide method for creating the definitions.
\end{itemize}

\subsection*{Package Handler Model}
As with languages, an abstract class is defined at first.
This definition contains only one function $proceed$ (listing \ref{lst:pmabst}) that finds and eliminates external references, as well as passes the package names to package handler.

\subsection*{Bash implementation}
The processing of popular Bash language was implemented.
As a sign of belonging to the Bash language, the file extension (".sh" and ".bash") and the first line ("#!/bin/bash") are used. 
All files that satisfy this conditions are passed to package managers modules, in our case - $apt$-$get$. 
TOSCA node containing a package and bash install script is defined by Node Type, Node Type Implementation, Package Artifact, Script Artifact.
This definitions are created my $createTOSCA\_Node$ method presented in listing \ref{lst:create_bash}.
now consider it in more details.
To avoid creating of the same nodes, we store names of created nodes in $created_packages$ list, and check it before start.
Then language specific node name is generated and TOSCA definitions for this name are created.

\subsubsection*{Apt-get Bash implementation}
The apt-get package manager module processing is fairly simple line-by-line file parser that searches for lines starting with the "$apt$-$get$ $install$" string and passes this command's arguments to package handler's public function $getPackage$ described later. 
The code can be found in the listing \ref{lst:bash_apt_parse}.
\subsection*{Ansible implementation}
To test the extensibility of the framework, the Ansible language was added.
Ansible is oft used for cloud application administration too.
Since ansible files are often packed to archives, it may be necessary to unpack them first and  then analyze the content.
Thus, the files are either immediately transferred to the package handler, or they are unzipped first.
Listing \ref{lst:ansible_proceed} presents this operations.
As a sign of the ansible language, the ".$yml$" extension is used, since this files doesn't contain specific header.\\
Creating a \gls{tosca} node for this language is a long operation. 
The basic moments are:
\begin{itemize}
	\item Analyze original files to determine an ansible configuration (set of options like username or proxy).
	\item It can be necessary to complete a configuration using user input.
	\item Create installation data (executable $yml$ file and folder with package)
	\item Pack installation data
	\item Create TOSCA definitions describing installation data
\end{itemize} 

\subsubsection*{Apt implementation}
Since the package installation using $ansible$ language and $apt$ package manager can be described in many different ways, the processing of is complicated too.
It's worth mentioning that the processing uses a simple state machine and regular expression from $java$.$util$.$regex$.

\section{Package Handling}
\if 0
Менеджер пакетов. Представляет из себя интерфейс для взаимодействия с менеджером пекетов операционной сисемы. 
\fi
\subsection*{Package downloading}
\if 0

Предоставляет 1 публичные функции, 
/**
* Download package and check its dependency
* 
* @param packet
*            package name
* @param cr
*            CSAR manager
* @param depth
*            dependency level to be checked
* @param listed
*            list with already included packages
* @return list of packages
* @throws JAXBException
* @throws IOException
*/
getPacket(Language language, String packet,
List<String> listed, String source, String sourcefile)
throws JAXBException, IOException 
для загрузки дерева зависимостей и передачи их менеджеру топологии
описание параметров
в случае если это первый загружаемый пакет в дереве зависимостей, необходимо явно указать используемую архитектуру
короткая вставка
для загрузки используется команда такая то
в случае неудачи используется юзеринпут, предоставляющий такие то опции решения проблемы
после загрузки вызывается функции создания ноды от языка
language.createTOSCA_Node(newName, sourcefile);
и одна функция обновления сервистэмплэйта из менеджера топологии
для создания зависимости от уже созданного нами пакета, или от пакета  из топологии... а это нужно?? посмотри код, может быть всё таки можно убрать?

\fi
\subsection*{Dependencies}
\if 0
для определения типа зависимости используется следующая команда, анализирующая вывод типа 
вставь пример
\fi
\section{Topology Handling}
\if 0
Менеджер топололгии служит для актуализации сервистэмплейтов. для этого на этабе препроцессинга он создаёт что то там
\fi
\subsection*{Update ServiceTemplate}
\if 0
Для обновления сервистэмплейта представлена следующая функция 
одна или 2 функции

описать ли что она делает??

\fi
\section{Finishing}
\if 0
Для завершения необходимо упаковать все изменённые данный обратно в Csar архив
используется функция архивировать из класса зип

\fi