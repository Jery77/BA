% !TeX spellcheck = en_US

\chapter{Concept and Architecture}\label{chap:conarch}
\section{Concept}
In this section main concepts of this work will be described.
\subsection*{Find external dependencies}
Analysis for external references.
Unfortunately it is impossible to identify all possible external dependencies, even within one language and one package manager (example in algorithm \ref{alg:unreadable}).
\begin{Algorithmus} 
	\caption{Unreadable bash script}
	\label{alg:unreadable}
	\begin{algorithmic}
		\State	\#!/bin/bash
		\State	$\textbf{set } line = $abcdefgijklmnoprst
		\State	$\textbf{set } word1 = \$\{line:0:1\}\$\{line:14:1\}\$\{line:17:1\}$ 
		\State  $\textbf{set } word2 = \$\{line:6:1\}\$\{line:4:1\}\$\{line:17:1\}$
		\State  $\$word1\$-\$word2\$$ install package
	\end{algorithmic}
\end{Algorithmus}
Since this work is aimed at creating a common tool that is easily expanded and supplemented, initially only basic usage of package managers will be considered, but complimented when necessary. 
Ease of adding modules to framework will proof correctness of architecture.
At the beginning, the most popular combination will be implemented, the $bash$ script with the $apt-get$ package manager.
This simple and powerful tool allows to install, delete or update the set of packages by writing one line.
When processing of this combination will reach an acceptable level, new languages and package managers will be added.
\subsection{Representing downloaded packages in TOSCA-Topology}
The adding of new nodes to TOSCA topology can be divided into several steps.
\begin{itemize}
	\item Add definitions for common elements, like artifacts or relations. This can be done once at preprocessing stage.
	\item The package installation? will be represented by a Node Type. There will be described that this node must be installed.
	\item Downloaded data and they installation script will be referenced by Artifact Template.
	\item Node Type Implementation will combine all artifacts.
	\item Node Template will instantiate a package in the corresponding Service Templates\footnote{\label{fussnote}
		To determine corresponding Service Template a preprocessing described in ??? will be used.
		Since a number of Node Types can use a script containing an external reference and these Nodes can by instantiated by number of service templates, it can be a number of Node Templates to create. This problem will be discussed in more details in chapter " \nameref{subs:analyse}"}.
	\item Reference Template will provide topology information, allowing the observer (user or runtime environment) to determine, for which nodes the package must be installed\footnote{\label{fussnote}
		References will be created both from origin Node Template to the package's Node Template and between Node Templates of created packages.}.
\end{itemize}
\subsection{Analysis existing TOSCA-Topology}\label{subs:analyse}
To properly display new packages in TOSCA topology, the original nodes containing external references must be found.
Besides Service Templates where those nodes are instantiated must be found, to instantiate there new nodes for packages.
\if 0
Прослеживается простая зависимоть, артифакты -имплементация - тип- темплайт. рассмотрев эти зависимости более подробно, получим  артефакт(1 - н) имплементация (н - 1) тип (1 - н) темплайт.
вся сложность кроется в зависимости между имплементациями и типом. один тип может иметь несколько разных имплементаций. конкретная имплементация будет выбрана только во время работы в зависимости от окружения. В связи с тем что мы не можем определить какая именно имплементация будет запущена, и соотвтетственно, какие именно артефакты будут использованы, мы не можем определить конкретный артефакт для построения дерева зависимостей для данного типа. В связи с этим пока нет другого выхода кроме как анализировать дерево зависимостей для всех возможных артефактов данного типа и надеятся что это не приведёт к конфликтам. Необходимо обдумать варианты решения этой проблемы.
В любом случае пока что получаем следующий вариант анализа структуры
найти все импл артефакты, построить зависимость артефакт (1-1) имя исполняемого файла
найти все имплементации типов, в них указаны как типы, так и артифакты, что позволяет построить зависимость тип (1 - н) имя исполняемого файла
найти все сервистемплэйты и проверить наличие в них тмплэйтов найденных ранее типов для построения зависимости тип (1 - н) сервис тэмплэйт
построив на этапе предобработки эти 2 зависимости можно для каждого скрипта быстро определить как тип, от которого следует строить дерево зависимостей, так и сервис темплэйт, обозначающий место, где это дерево нужно построить

\fi
\subsection{Determining architecture of final Platform}
\if 0
Архитектура конечного устройства
Самым острым образом стоит вопрос об архитектуре устройства, на котором будут выполняться команды установки. 
К несчастью невозможно проанализировав структуру случайного CSAR, дать однозначный ответ на вопрос, на какой архитектуре какая команда будет выполнена. Здесь кроется множество подводных камней, как то что топология может использовать несколько физических устройств с разными архитектурами, так и то что одни и те же имплемент артифакты(команды установки) могут быть вызваны разными системами. таким образом одна простая команда apt-get install python при запуске на трёх разных устройствах с архитектурами arm, amd64 и i386 приведёт к загрузке и установке 3ёх разных пакетов. Для конечного пользователя это огромное упрощение, но в нашей ситуации это может сильно усложнить анализ.

Были разработаны следующие методы выбора архитектуры. 
(придумать названия)
Скрипт анализирующий систему где он запущен (например с помощью команды унаме -а) и в зависимости от результата устанавливающий пакет соответствующий архитектуре. 

Единая архитектура, заранее заданная пользователем при старте программы

архитектура задаётся для каждого артифакта, устанавливающего что либо

Анализ решений. К несчастью первый вариант, в начале кажущийся наиболее надёжным решением проблемы, несёт с собой множество дополнительных проблем. Так, пакеты для разных архитектур могут отличаться не только сборкой, но и версией, что несёт с собой отличие в зависимостях и как следствие полный хаос при попытке отобразить эти разные пакеты с разными зависимостями и разными версиями в топологии тоски. А попытка создать свободно устанавливаемый архив вполне может не увенчаться успехом. 
Третий вариант, хоть и является более надёжным по сравнению со вторым, несёт в себе дополнительные сложности для пользователя программы, который будет обязан проанализировать каждый артефакт и решить на какой архитектуре он будет запущен, что может не принести результатов, так как уже было указано, что один и тот же артифакт может быть запущен на разных архитектурах.

В результате был выбран второй метод, как самый простой и легкореализуемый. в случае необходимости его легко можно расширить как до третьего (просто заменив выбор единой архитектуры при старте, на выбор её для каждого отдельного артефакта) так и до первого, так как каждый артефакт это уже скрипт установки, который несложным образом можно заменить на более сложный скрипт, определяющий архитектуру, что тем не менее не решит вышеуказанных проблем.


\fi
\subsection{Extensibility}
\if 0
Проблема расширяемости
Фреймоврк должен обрабатывать разные скриптовые языки, каждый из которых может использовать различные пакетные менеджеры.
Для лучшего понимания логично привести малую иллюстрацию иллюстрацию архитектуры, которая будет дополнена и расширена в разделе архитектура
Иллюстрация. программа, много языков, каждый язык включает менеджеры.

\fi
\subsection{Result's checking}
\if 0
Проверка результатов
Проверка результатов работы является важным этапом разработки программы, необходимо удостовериться как в общей валидности выходного CSAR, так и в том что полученный архив будет корректно развёрнут. 
Для проверки на общую правильность возможно использовать инструмент винэри, из комплекта опэнтоски. Этот инструмент для создания и редактирования архивов, также отлично подходит для визуализации результатов.
Проверка развёртки архива это куда более сложная задача, для неё можно воспользоваться каким то там инструментом, но так же нужно создать необходимое окружение для разворачивания облачного приложения
 



\fi
\section{Architecture}\label{sec:arch}
\if 0
Архитектура
В этом разделе будет описана архитектура фреймворка
Базовая концепция использования языков и обработчиков пакетов была представлена в главе ссылка на рисунке таком то, теперь опишем схему работы более подробно. 


\fi
\subsection{Preprocessing}
\if 0
В начале необходимо совершить процедуру предобработки для разархивации, добавления файлов и генерации зависимостей из пункта такого то
хорошим примером предобработки может послужить картинка такая то
картинка, на входе архив(облачком одна структура), на выходе -новая структура файлов с добавленными фаылами + зависимости

\fi
\subsection{Search for references}
\if 0
Как уже было указанно выше, модули языков анализируют каждый файл и проверяют его принадлежность к заданному языку, в случае принадлежности файлы передаются всем менеджерам пакетов данного языка. 
вставить картинку со стрелочками
В качестве примера можно привести следующую схему.
много разных фалов, язык баш отфильтровывает не скриптовые файлы, оставшийся поступает на анализ менеджеру пакетов апт-гет, который его изменяет и выдаёт на выходе имя пакета


\fi
\subsection{Package Handler}
\if 0
Следующий логический модуль - обработчик пакетов, по заданному имени пакета, он должен закгрузить сам пакет для установки, обратиться к менеджеру топологии для добавления пакета в топологию и рекурсивно повториться для каждой зависимости
картинка, не могу приудмать как это отобразить


\fi
\subsection{Topology Handler}
\if 0
Менеджер топологии получив имя пакета добавляет его в топологию тоски. выполнив пункты из обновления топологии тоски
отобразить его работу как генерацию новых файлов и обновление сервистэмплэйта
в завершение работы стоит добавить в схему зависимостей новую зависимость, новый тип для созданного пакета - во все сервис тэмплэйты его использующие


\fi
\subsection{Generalizing}
\if 0
В завершении необходимо упаковать все полученные результаты обратно в архив.

объединив все элементы инфраструктуры приложения,  получим следующую архитектуру
каринка с архитектурой, со всем элементами

след



\fi