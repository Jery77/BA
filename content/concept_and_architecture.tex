% !TeX spellcheck = en_US

\chapter{Concept and Architecture}\label{chap:conarch}
\section{Concept}
\if 0
В этом разделе будет разъеснена концепция данной работы

\fi
\subsection*{Finding external dependencies}
\if 0
Анализ на внешние ссылки. 
К несчас, тью невозможно выявить все возможные внешние зависимости даже в рамках одного языка, и одного менеджера пакетов (пример какой нить страшный, скрипт нечитаемый вставь), а так как данная работа направленна на создание общего инструмента, легко расширяемого и дополняемого, мы рассмотрим только базовые методы использования менеджеров пакетов, дополняя их по мере необходимости. Эта возможность легко расширять программу, так же будет являться свидетельством корректности её архитектуры в вопросе дополняемости.
В начала логично реализован разбор самой простую и популярную комбинацию, баш скрипт с менеджером пактов apt-get 
Этот простой и мощный инструмент позволяет в одну строчку устанавливать, удалять или обновлять заданный список пакетов.
Когда обрабтка данной комбинации язык-менеджер пакетов будет производиться на приемлимом уровне, можно будет добавлять дополнительные языки и менеджеры пакетов

\fi
\subsection*{Representing packages in TOSCA-Topology}
\if 0
Отображение пакетов в топологии. Процесс добавления новых ячеек для устанавливаемых пакетов необходимых ячейке 1 в топологию тоски можно разделить на несколько шагов. 
в начале необходимо создать nodetype для данных пакетов. 
необходимо создать файы описания артефактов, implementation для скрипта и deployment для пакета
Далее нужно имплементировать этот NodeType  создав nodetypeimplementation и добавив в него только что созданные артифакты
обновить сервистэмплате, создержащий ячейку 1, (если таких темплэйтов несколько - нужно обновить каждый отдельно)
добавить в него темплайт пакета и зависимости между ними, как было указано в разделе менеджеров пакетов, этих зависимостей может быть 2 вида. 
для зависимостей между ячейками созданными дынным фреймворком будет использоваться зависимость заданная в метаданных пакетов.
для зависимости между старыми и новыми ячейками всегда будет использована зависимость пререк.
обе зависимости , как и артифакты необходимо добавить в топологию на этапе предобработки

\fi
\subsection*{Analysis existing TOSCA-Topology}
\if 0
Анализ топологии тоски
для отображения новых пакетов в топологии, самых первых, придумай как это описать (предыдущий пункт) необходимо определить как нодетайпы, использующие заданный артефакт, так и сервис тэмплэйты, в которых эти нодетайпы используются.
Прослеживается простая зависимоть, артифакты -имплементация - тип- темплайт. рассмотрев эти зависимости более подробно, получим  артефакт(1 - н) имплементация (н - 1) тип (1 - н) темплайт.
вся сложность кроется в зависимости между имплементациями и типом. один тип может иметь несколько разных имплементаций. конкретная имплементация будет выбрана только во время работы в зависимости от окружения. В связи с тем что мы не можем определить какая именно имплементация будет запущена, и соотвтетственно, какие именно артефакты будут использованы, мы не можем определить конкретный артефакт для построения дерева зависимостей для данного типа. В связи с этим пока нет другого выхода кроме как анализировать дерево зависимостей для всех возможных артефактов данного типа и надеятся что это не приведёт к конфликтам. Необходимо обдумать варианты решения этой проблемы.
В любом случае пока что получаем следующий вариант анализа структуры
найти все импл артефакты, построить зависимость артефакт (1-1) имя исполняемого файла
найти все имплементации типов, в них указаны как типы, так и артифакты, что позволяет построить зависимость тип (1 - н) имя исполняемого файла
найти все сервистемплэйты и проверить наличие в них тмплэйтов найденных ранее типов для построения зависимости тип (1 - н) сервис тэмплэйт
построив на этапе предобработки эти 2 зависимости можно для каждого скрипта быстро определить как тип, от которого следует строить дерево зависимостей, так и сервис темплэйт, обозначающий место, где это дерево нужно построить

\fi
\subsection*{Determining architecture of final Platform}
\if 0
Архитектура конечного устройства
Самым острым образом стоит вопрос об архитектуре устройства, на котором будут выполняться команды установки. 
К несчастью невозможно проанализировав структуру случайного CSAR, дать однозначный ответ на вопрос, на какой архитектуре какая команда будет выполнена. Здесь кроется множество подводных камней, как то что топология может использовать несколько физических устройств с разными архитектурами, так и то что одни и те же имплемент артифакты(команды установки) могут быть вызваны разными системами. таким образом одна простая команда apt-get install python при запуске на трёх разных устройствах с архитектурами arm, amd64 и i386 приведёт к загрузке и установке 3ёх разных пакетов. Для конечного пользователя это огромное упрощение, но в нашей ситуации это может сильно усложнить анализ.

Были разработаны следующие методы выбора архитектуры. 
(придумать названия)
Скрипт анализирующий систему где он запущен (например с помощью команды унаме -а) и в зависимости от результата устанавливающий пакет соответствующий архитектуре. 

Единая архитектура, заранее заданная пользователем при старте программы

архитектура задаётся для каждого артифакта, устанавливающего что либо

Анализ решений. К несчастью первый вариант, в начале кажущийся наиболее надёжным решением проблемы, несёт с собой множество дополнительных проблем. Так, пакеты для разных архитектур могут отличаться не только сборкой, но и версией, что несёт с собой отличие в зависимостях и как следствие полный хаос при попытке отобразить эти разные пакеты с разными зависимостями и разными версиями в топологии тоски. А попытка создать свободно устанавливаемый архив вполне может не увенчаться успехом. 
Третий вариант, хоть и является более надёжным по сравнению со вторым, несёт в себе дополнительные сложности для пользователя программы, который будет обязан проанализировать каждый артефакт и решить на какой архитектуре он будет запущен, что может не принести результатов, так как уже было указано, что один и тот же артифакт может быть запущен на разных архитектурах.

В результате был выбран второй метод, как самый простой и легкореализуемый. в случае необходимости его легко можно расширить как до третьего (просто заменив выбор единой архитектуры при старте, на выбор её для каждого отдельного артефакта) так и до первого, так как каждый артефакт это уже скрипт установки, который несложным образом можно заменить на более сложный скрипт, определяющий архитектуру, что тем не менее не решит вышеуказанных проблем.


\fi
\subsection*{Extensibility}
\if 0
Проблема расширяемости
Фреймоврк должен обрабатывать разные скриптовые языки, каждый из которых может использовать различные пакетные менеджеры.
Для лучшего понимания логично привести малую иллюстрацию иллюстрацию архитектуры, которая будет дополнена и расширена в разделе архитектура
Иллюстрация. программа, много языков, каждый язык включает менеджеры.

\fi
\subsection*{Result's checking}
\if 0
Проверка результатов
Проверка результатов работы является важным этапом разработки программы, необходимо удостовериться как в общей валидности выходного CSAR, так и в том что полученный архив будет корректно развёрнут. 
Для проверки на общую правильность возможно использовать инструмент винэри, из комплекта опэнтоски. Этот инструмент для создания и редактирования архивов, также отлично подходит для визуализации результатов.
Проверка развёртки архива это куда более сложная задача, для неё можно воспользоваться каким то там инструментом, но так же нужно создать необходимое окружение для разворачивания облачного приложения
 



\fi
\section{Architecture}
\if 0
Архитектура
В этом разделе будет описана архитектура фреймворка
Базовая концепция использования языков и обработчиков пакетов была представлена в главе ссылка на рисунке таком то, теперь опишем схему работы более подробно. 


\fi
\subsection*{Preprocessing}
\if 0
В начале необходимо совершить процедуру предобработки для разархивации, добавления файлов и генерации зависимостей из пункта такого то
хорошим примером предобработки может послужить картинка такая то
картинка, на входе архив(облачком одна структура), на выходе -новая структура файлов с добавленными фаылами + зависимости

\fi
\subsection*{Search for references}
\if 0
Как уже было указанно выше, модули языков анализируют каждый файл и проверяют его принадлежность к заданному языку, в случае принадлежности файлы передаются всем менеджерам пакетов данного языка. 
вставить картинку со стрелочками
В качестве примера можно привести следующую схему.
много разных фалов, язык баш отфильтровывает не скриптовые файлы, оставшийся поступает на анализ менеджеру пакетов апт-гет, который его изменяет и выдаёт на выходе имя пакета


\fi
\subsection*{Package Handler}
\if 0
Следующий логический модуль - обработчик пакетов, по заданному имени пакета, он должен закгрузить сам пакет для установки, обратиться к менеджеру топологии для добавления пакета в топологию и рекурсивно повториться для каждой зависимости
картинка, не могу приудмать как это отобразить


\fi
\subsection*{Topology Handler}
\if 0
Менеджер топологии получив имя пакета добавляет его в топологию тоски. выполнив пункты из обновления топологии тоски
отобразить его работу как генерацию новых файлов и обновление сервистэмплэйта
в завершение работы стоит добавить в схему зависимостей новую зависимость, новый тип для созданного пакета - во все сервис тэмплэйты его использующие


\fi
\subsection*{Generalizing}
\if 0
В завершении необходимо упаковать все полученные результаты обратно в архив.

объединив все элементы инфраструктуры приложения,  получим следующую архитектуру
каринка с архитектурой, со всем элементами

след



\fi