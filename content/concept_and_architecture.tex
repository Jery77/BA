% !TeX spellcheck = en_US

\chapter{Concept and Architecture}\label{chap:conarch}
\section{Concept}
In this section main concepts of this work will be described.
In general, the structure of framework can be described by the diagram \ref{fig:gen}.
\input{graphics/general}


\subsection{Analysis existing TOSCA-Topology}\label{subs:analyse}
To properly display new packages in \gls{tosca} topology, it is necessary to add to each node containing an external reference a reference to newly created node resolving the external reference. 
Besides Service Templates must be found where those nodes are instantiated.
As was already pointed, according to \gls{tosca} standard a simple sequence can be build:\\
$script$ $\rightarrow$ $Artifact$ $Implementation$ $\rightarrow$ $Node$ $Type$ $Implementation$ $\rightarrow$ $Node$ $Type$ $\rightarrow$ $Node$ $Template$ $\rightarrow$ $Service$ $Template$\\
Now consider this bindings in more detail. 
\begin{itemize}
	\item $script$ $\rightarrow$ $Artifact$ $Implementation$\\
	A script can be referenced by several Artifact Implementations (Despite the fact that this is a bad practice).
	\item  $Artifact$ $Implementation$ $\rightarrow$ $Node$ $Type$ $Implementation$ \\
	The same way an artifact can be used by several Node Type Implementations.
	\item $Node$ $Type$ $Implementation$ $\rightarrow$ $Node$ $Type$ \\
	Node Type Implementation can describe implementation of only one Node Type
	\item  $Node$ $Type$ $\rightarrow$ $Node$ $Template$\\
	Each Node Type can have a lot of Node Templates
	\item  $Node$ $Template$ $\rightarrow$ $Service$ $Template$
	But each Node Template will be defined only in one Service Template.
\end{itemize}
Thus structure can be described not by a sequence, but by a tree with the script as a root, and Service Templates as leaves (Example in figure \ref{fig:script_serv}). 
\input{graphics/script_serv_tree}
Of course it is possible to move in opposite direction, starting from a Node and moving toward scripts, but this method brings additional complexity. 
Node Type can have several Node Type Implementations, but which one will be used can be determined only during deployment. 
The method presented above can uniquely determine Node Templates and Service Template for a given script.
Of course it is not guaranteed that found Node Type Implementation will be used during deployment, but we can't do anything with this. 
The following steps can be executed during a preprocessing, to identify necessary dependencies.
\begin{itemize}
	\item Find all Artifact Implementations to build dependency from script name to Artifact Implementation.
	\item Find all Node Type Implementation. Since those definitions contains both the Node Type and used Artifact Implementations, the dependency from script to Node Types can be build.
	\item Find all Service Templates, and in them contained Node Templates. So the necessary dependencies can be achieved (script to Node Template and script to Service Template).
\end{itemize}
\subsection*{Find external dependencies}
Analysis for external references.
Unfortunately it is impossible to identify all possible external dependencies, even within one language and one package manager (example in algorithm \ref{alg:unreadable}).
\begin{Algorithmus} 
	\caption{Unreadable bash script}
	\label{alg:unreadable}
	\begin{algorithmic}
		\State	\#!/bin/bash
		\State	$\textbf{set } line = $abcdefgijklmnoprst
		\State	$\textbf{set } word1 = \$\{line:0:1\}\$\{line:14:1\}\$\{line:17:1\}$ 
		\State  $\textbf{set } word2 = \$\{line:6:1\}\$\{line:4:1\}\$\{line:17:1\}$
		\State  $\$word1\$-\$word2\$$ install package
	\end{algorithmic}
\end{Algorithmus}
Since this work is aimed at creating a common tool that is easily expanded and supplemented, initially only basic usage of package managers will be considered, but complimented when necessary. 
Ease of adding modules to framework will proof correctness of architecture.
At the beginning, the most popular combination will be implemented, the $bash$ script with the $apt-get$ package manager.
This simple and powerful tool allows to install, delete or update the set of packages by writing one line.
When processing of this combination will reach an acceptable level, new languages and package managers will be added.
\subsection{Representing downloaded packages in TOSCA-Topology} \label{subs:repres}
A package node denote to defined and instantiated element of \gls{tosca} topology, the purpose of which is to install the package.
The adding of new package nodes to TOSCA topology can be divided into several steps.
\begin{itemize}
	\item Add definitions for common elements, like artifacts or relations. This can be done once at preprocessing stage.
	\item The package node definition will be represented by a Node Type. There will be described that this node must be installed.
	\item Downloaded data and they installation script will be referenced by Artifact Template.
	\item Node Type Implementation will combine all artifacts.
	\item Node Template will instantiate a package in the corresponding Service Templates.
		To determine corresponding Service Template a preprocessing described in \nameref{subs:analyse} will be used.
	\item Reference Template will provide topology information, allowing the observer (user or runtime environment) to determine, for which nodes the package must be installed.
		References will be created both from origin Node Template to the package's Node Template and between Node Templates of created packages.
\end{itemize}
\subsection{Determining architecture of a final Platform}
The most acute way is the question about the architecture of the device where deployment scripts will be executed.
Unfortunately, it is impossible to analyze the structure of any CSAR and give an unambiguous answer to the question, on which architecture which command will be executed.
There are many pitfalls here.
A single Service Template can use several physical devices with different architectures.
The same Implementation Artifacts can refer to different Node Types, instantiated on different platforms.
So one simple Implementation Artifact with bash script containing "$apt$-$get$ $install$ $python$" command when deployed on different devices (for example with arm, amd64 and i386 architectures) will result in the loading and installation of 3 different packages. 
For an end user, the ability to use such a simple command is a huge relief, but for the framework it can greatly complicate analysis.
The following methods of architecture selection were designed.
\begin{itemize}
	\item Deployment environment analysis\\
	The script analyzing the system where it is running (for example using $uname$ $-a$ command) and depending on the result, installing the package corresponding to the architecture.
	\item Unified architecture\\
	An Unified architecture, predefined by the user at framework startup.
	\item Artifact specific architectures\\
	An architecture can be defined for each artifact.
\end{itemize}
\subsubsection*{Analysis of methods}
Unfortunately, the Deployment environment analysis, which at first glance seems to be the most reliable solution, brings many additional problems.
Packages for different platforms can differ not only by architecture, but also in the versions and the list of dependencies.
As a consequence, a complete chaos will be produced when trying to display these different packages with different versions in the \gls{tosca}-topology.
The only robust solution would be to create for each installed package a set of archives (one archive for each architecture), containing the entire dependency tree for the given package.
But this approach contradicts one of the ideas of this work: each package should be mapped in topology.\\
The Artifact specific architectures carries additional complexity to the user of the framework.
The user will be obligate to analyze each artifact and decide on which architecture it will be executed. 
This can be complicated by the fact that the same artifact can be executed on different architectures.\\
The method of the unified architecture was chosen, as the most simple and easy to implement.
If it will be necessary, this method can be easy expanded to Artifact specific architectures method (be replacing the user input to chose an unified architecture at start, by choosing an architecture for each artifact.) and to Deployment environment analysis (By downloading packages for all available architectures and adding the architecture determination to installation script.).

\subsection{Extensibility}
Framework should handle different script languages, each of them should support a various package managers.
This principle can be illustrated by a figure \ref{fig:lang_pm}.
\input{graphics/languages_pm}

\subsection{Result's checking}
Checking the results of the work is an important stage in the development of the program.
It is necessary to verify both the overall validity of the output \gls{csar}, and the possibility to deploy the output \gls{csar}.
To test for overall correctness, it is possible to use winery tool from OpenTOSCA.
This tool for creating and editing archives is also great for visualizing results.
Checking the deployment of the CSAR is a much more complicated task, for which OpenTOSCA runtime environment can be used. 
But it's also necessary to create proper environment for deploying the cloud application.

\section{Architecture}\label{sec:arch}
This section will present the architecture of the framework and a description of its modules.
The main modules of the Framework are: Language modules, Package manager modules, Package handler module and Topology handler module.

\subsection{Preprocessing} \label{subs:archpp}
At the beginning the preprocessing will be executed for decompression, adding files and generating dependencies (generation is described in section \ref{subs:analyse}).
Figure \ref{fig:preproc} illustrates the stages of preprocessing.
\input{graphics/preprocessing}
\subsection{Language modules} \label{subs:archlm}
As already mentioned above, language modules analyze each file and check its belonging to the specific language. 
Files not belonging to the language are filtered out.
The remaining files are transferred to this language's package manager modules.
For example a $Bash$ module can pass through only files with ".sh" extension and starting with the "\#!/bin/bash" line.
\subsection{Package manager modules} \label{subs:archpmm}
Package managers modules should find external references, resolve them and transmit package name to package handler module, described in next section.
Figure \ref{fig:lang_ph} illustrates data flow between languages, package managers and package handler.
\input{graphics/lang_ph}

\subsection{Package Handler} \label{subs:archph}
Package Handler fr a given package name should download installation package, transfer package name to Topology handler and recursively repeat actions for all depended packages.

\subsection{Topology Handler} \label{subs:archtop}
The Topology Handler adds package to the topology. 
This includes adding new files and updating existing files. 
Necessary steps was described in section \ref{subs:repres}.

\subsection{Shutting down} \label{subs:archend}
At the end all results will be packed back to the archive.
\if 0
В завершении необходимо упаковать все полученные результаты обратно в архив.



\fi