% !TeX spellcheck = en_US

\chapter{Concept and Architecture}\label{chap:conarch}
\section{Concept}
In this section, the main concept of this work will be described.
The general structure of framework is represented in diagram \ref{fig:gen}.
\input{graphics/general}


\subsection{Analysis existing TOSCA-Topology}\label{subs:analyse}
To properly update the \gls{tosca} topology, it is necessary to add references from the nodes where external references were to newly created nodes, which resolve the external references. 
According to the TOSCA standard, only references between Node Templates in the same Service Template can be created.  
That means that each Node Template, which uses artifacts with external references must be found.
Furthermore, Service Template where the Node Templates are instantiated must be found to create there a Node Template for the new nodes and reference them to the Node Templates with external references.
The Pointers to Artifacts are contained by Artifact Templates, which are used by Node Type Implementations.
By composing all the information a simple references chain can be built:\\
$Artifact$ $\rightarrow$ $Artifact$~$Template$ $\rightarrow$ $Node$~$Type$~$Implementation$ $\rightarrow$ $Node$~$Type$ $\rightarrow$ $Node$~$Template$ $\rightarrow$ $Service$~$Template$\\
Now consider the references in more detail. 
\begin{itemize}
	\item $Artifact$ $\rightarrow$ $Artifact$ $Template$\\
	An Artifact can be referenced by several Artifact Templates. (Despite the fact that this is a bad practice.)
	\item  $Artifact$ $Template$ $\rightarrow$ $Node$ $Type$ $Implementation$ \\
	The same way an Artifact Template can be used by several Node Type Implementations.
	\item $Node$ $Type$ $Implementation$ $\rightarrow$ $Node$ $Type$ \\
	A Node Type Implementation can describe an implementation of only one Node Type.
	\item  $Node$ $Type$ $\rightarrow$ $Node$ $Template$\\
	Each Node Type can have any number of Node Templates.
	\item  $Node$ $Template$ $\rightarrow$ $Service$ $Template$\\
	But each Node Template is instantiated only once.
\end{itemize}
Thus structure can be described by a tree with an Artifact as the root, and Service Templates as leaves (The example is on figure \ref{fig:script_serv}) and will be called the internal dependencies tree.
\input{graphics/script_serv_tree}
%Of course it is possible to move in opposite direction, starting from a Node and moving toward scripts, but this method brings additional complexity. 
An additional problem is in the reference between a Node Type and a Node Type Implementation.
Node Type can have several implementations, but which one will be used will be determined only during the deployment. 
The chosen solution to this problem is to use each Node Type Implementation in hope, that they will not conflict.\\
%The method presented above can uniquely determine Node Templates and Service Template for a given script.
%Of course it is not guaranteed that found Node Type Implementation will be used during deployment, but we can't do anything with this. 
The following steps can be executed during the preprocessing, to build the internal dependencies tree.
\begin{itemize}
	\item Find all Artifact Templates to build references from Artifacts to Artifact Templates.
	\item Find all Node Type Implementations. Because they contain references both to the Node Type and to the Artifact Templates, then the dependency from Artifact to Node Types can be built.
	\item Find all Service Templates and in them contained Node Templates. Each Node Template contains a reference to Node Type, what is useful for building a dependency from Artifact to Node Template.
\end{itemize} 
In this way, the required internal dependencies tree can be built (with references $Artifact$ $\rightarrow$ $Node$~$Template$ and $Artifact$ $\rightarrow$ $Service$~$Template$).
\subsection{Analysis for external references}
Unfortunately, it is impossible to identify all possible external references, even when one language and one package manager are used (example in the listing \ref{alg:unreadable}).

\begin{Listing} 
	\caption{Unreadable bash script}
	\label{alg:unreadable}
\begin{lstlisting}
#!/bin/bash
set  line = abcdefgijklmnoprst
set  word1 = ${line:0:1}${line:14:1}${line:17:1} 
set  word2 = ${line:6:1}${line:4:1}${line:17:1}
$word1-$word2 install package
\end{lstlisting}
\end{Listing}
Since this work is aimed at creating of the easily expanded and supplemented tool, initially only basic usage of package managers will be considered.
% and complimented only when it will be necessary. 
Ease of adding modules to the framework will proof the correctness of architecture.\\
At the beginning, the most popular combination will be implemented: the $bash$ script with the $apt-get$ package manager.
This simple and powerful tool allows to install, delete or update the set of packages in one line.
After the modules for this combination will be implemented, new languages and package managers should be added.
\subsection{Representing downloaded packages in TOSCA-Topology} \label{subs:repres}
A package node denotes to the defined and instantiated element of \gls{tosca} topology, the purpose of which is to install the package.
The adding of new package nodes to TOSCA topology can be divided into several steps.
\begin{itemize}
	\item Add definitions for common elements, like Artifact Types or Relationship Types. 
		This can be done once at the preprocessing stage.
	\item The package node main definition will be represented by a Node Type. 
		%There will be described that this node must be installed.
	\item Artifacts (The downloaded data and the installation script) will be referenced by Artifact Templates.
	\item Node Type Implementation will combine the artifacts.
	\item Node Template will instantiate the package node in the corresponding Service Templates.
		To determine corresponding Service Template the preprocessing described in the section \nameref{subs:analyse} will be used.
	\item Reference Template will provide topology information, allowing the observer (a user or a runtime environment) to determine, for which nodes the package must be installed.
		References will be created from the Node Template needing the package to Node Template of created package nodes.
\end{itemize}
\subsection{Determining architecture of a final platform}
An another problem appears during choosing the architecture of the device where packages will be installed.
Unfortunately, it is impossible to analyze the structure of any CSAR and give an unambiguous answer to the question, on which architecture which node will be deployed.
There are many pitfalls here.\\
A single Service Template can use several physical devices with different architectures.
One Implementation Artifacts can be referred by different Node Types and Node Templates, instantiated on different platforms.
This way one simple Implementation Artifact with a bash script containing "$apt$-$get$ $install$ $python$" command can be deployed on different devices within one Service Template (for example with the arm, amd64 and i386 architectures) and will result in the loading and installation of three different packages. 
For an end user, the ability to use such a simple command is a huge advantage, but for the framework, it can greatly complicate analysis.
The following methods of architecture selection were designed.
\begin{itemize}
	\item $Deployment$ $environment$ $analysis$\\
	The script can analyze the system where it was started (for example using the "$uname$~$-a$" command) and depending on the result, it will install the package corresponding to the system's architecture.
	\item $Unified$ $architecture$\\
	The architecture will be defined by the user for a whole CSAR.
	\item $Artifact$ $specific$ $architecture$\\
	The architecture will be defined separately for each artifact.
\end{itemize}
\subsubsection*{Analysis of methods}
Unfortunately, the $deployment$ $environment$ $analysis$, which at first sight seems to be the most reliable solution, brings many additional problems.
Packages for different platforms can differ not only by architecture but also by the version and the list of dependencies.
As a consequence, a chaos can be produced by mirroring these different packages with different versions to the \gls{tosca}-topology.
The only robust solution seems to be to create for each installed package a set of archives (one archive for one architecture), containing the entire dependency tree for the given package.
But this approach contradicts one of the main ideas of this work: the dependencies trees should be mapped to the topology.\\
The $artifact$ $specific$ $architecture$ method carries an additional complexity to the user of the framework.
It will obligate a user to analyze each artifact and decide on which architecture it will be executed. 
This can be complicated by the fact that the same artifact can be executed on different architectures.\\
The method of the $unified$ $architecture$ was chosen, as the simplest and easiest to implement.
If it will be necessary, this method can be easily expanded to the $artifact$ $specific$ $architectures$ method (By removing the user input at start, and choosing an architecture for each artifact separately.) or to $deployment$ $environment$ $analysis$ (By downloading packages for all available architectures and adding the architecture determining algorithm to the installation scripts.).

\subsection{Extensibility}
The framework should handle different languages, each of them can support various package managers.
This principle can be illustrated by a figure \ref{fig:lang_pm}.
\input{graphics/languages_pm}

\subsection{Result's checking}
Checking the output of the framework is an important stage in the development of the program.
It is necessary to verify both the overall validity of the output \gls{csar} and the possibility to deploy generated package nodes.
To test for overall correctness it is possible to use $winery$ tool from OpenTOSCA.
This tool for creating and editing CSAR archives is also great for visualizing the results.
Checking the deployment of the generated package nodes can be done manual by starting corresponding commands.

\section{Architecture}\label{sec:arch}
This section will present the architecture of the framework and a description of its elements.
The main elements are $references$ $resolver$, $language$ $modules$, $package$ $manager$ $modules$, $package$ $handler$ and $topology$ $handler$.

\subsection{CSAR handler} \label{subs:casr_h}
The CSAR handler provides access to \gls{csar} and maintains it's consistency. 
It describes the process of adding new files (to handle the metadata), decompression, architecture processing, etcetera.

\subsection{References resolver} \label{subs:RR}
This is the main element, the execution of which can be divided into three stages: $preprocessing$, $processing$, $finish$. \\
At the begin the $preprocessing$ will be executed for decompression, adding files (The list of common files, which are added during preprocessing is described in the section \ref{subs:repres}) and generating internal dependencies trees (the generation is described in the section \ref{subs:analyse}).
Figure \ref{fig:preproc} illustrates the stages of the preprocessing.\\
\input{graphics/preprocessing}
During the $processing$, all $language$ $modules$ will be activated, which are described in the next section. \\
To finish the work  all results will be packed back to the archive during the $finish$ stage.
\subsection{Language modules} \label{subs:archlm}
Each $language$ $module$ describes one language and helps to choose files written in the language.
As already mentioned above, during $processing$ stage a $language$ $module$ analyzes all files one by one and checks its belonging to the specified language. 
Any files not belonging to the described language are filtered out.
The remaining files are transferred to the $language$ $module$'s $package$ $manager$ $modules$.
For example, a $Bash$ module can pass through only files with $".sh"$ extension and starting with the $"\#!/bin/bash"$ line.
\subsection{Package manager modules} \label{subs:archpmm}
A $package$ $managers$ $module$ finds external references, resolves them and transmits the package name to the $package$ $handler$, described in the next section.
Figure \ref{fig:lang_ph} illustrates data flow between language modules, package manager modules, and package handler.
\input{graphics/lang_ph}

\subsection{Package Handler} \label{subs:archph}
The $package$ $handler$ becomes a package name, downloads a data for the package installation, transfers the package name to the $topology$ $handler$ and recursively repeats the actions for all depended packages.

\subsection{Topology Handler} \label{subs:archtop}
$Topology$ $handler$ adds a package to the topology. 
This includes adding new files and updating existing files. 
Necessary steps were described in section \ref{subs:repres}.